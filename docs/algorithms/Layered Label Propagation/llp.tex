\section{\textit{Layered Label Propagation}}

  A principal ideia dos algoritmos de \textit{Label Propagation} seguem um padrão comum. Estes algoritmos consistem num conjunto de iterações e no início é atribuído a cada vértice uma \textit{label} que representa o \textit{cluster} a que pertence. No início do algoritmo, cada vértice tem uma \textit{label} diferente. O critério de atribuição da \textit{label},a cada vértice, é o que diferencia os vários algoritmos de \textit{Label Propagation}. Um dos algoritmos mais conhecidos é o \textit{Standard Label Propagation}, em que a regra de atribuição da \textit{label} a um vértice é a \textit{label} que ocorrer mais frequentemente na sua vizinhança. 
  
  Uma outra variante, denominada \textit{Absolute Pott Model}, indica que a \textit{label} que é atribuída ao vértice é a que maximiza a seguinte equação: 
 
  \begin{center}
    \begin{equation}
      \label{apmeq}
      ki-\gamma(vi-ki)
    \end{equation}
  \end{center}    
  
  Sendo, $ki$ os vértices na vizinhança que têm a $label_i$ e $v_i$ todos os vértices que têm a $label_i$.
  Este algoritmo pode ser descrito da seguinte forma:
  
  \begin{algorithm}[H]
    \caption{\textit{Absolute Pott Model}}\label{apmalg}
    \begin{enumerate}
    \item Obter uma permutação do grafo.
    \item Iniciar todos os vértices atribuindo uma \textit{label} única e por $v_i=1$ para cada $label_i$ .
    \item Iterar sobre a permutação obtida e para todas as \textit{labels} na vizinhança de cada vértice ver qual é maximizada pela equação \ref{apmeq} e atribuir ao vértice essa \textit{label}. Decrementar $v_i$ para a \textit{label} antiga e incrementar o $v_i$ correspondente à nova \textit{label}.
    \end{enumerate}
  \end{algorithm}

  Ambos os algoritmos apresentados anteriormente têm alguns problemas. O \textit{Standard Label Propagation} tende a produzir um \textit{clusters} de grandes dimensões(contendo a maior parte dos vértices) e o \textit{Absolute Pott Model} tem o problema de não se saber à partida o valor ideal para $\gamma$.
  
  \subsection{Algoritmo de \textit{Layered Label Propagation}}
  Baseado no algoritmo \textit{Standard Label Propagation} surgiu o \textit{Layered Label Propagation}. Este algoritmo consiste no seguinte:
  
  \begin{algorithm}[H]
    \caption{\textit{Layered Label Propagation}}\label{llpalg}
    \begin{enumerate}
    \item Para cada iterações chamar o Algoritmo \ref{apmalg} tendo $gama$ valores compreendidos dentro do seguinte conjunto: $\{0\}\cup\{2^{{-}i},i=0,...,K\} $.
    \item Com o \textit{output} resultante da chamada ao Algoritmo \ref{apmalg}, ordenar os vértices de modo a que os que tenham a mesma \textit{label} fiquem próximos. Para vértices que estejam na mesma comunidade (têm a mesma \textit{label}) é mantida a sua ordem.
    \end{enumerate} 
  \end{algorithm}
  
  \paragraph{Exemplo} Para o grafo da Figura \ref{graph0llp} pode-se calcular 
de forma sequencial o Layered Label Propagation, para cada iteração $i$, 
começando por se fazer uma permutação($\pi_i$) dos vértices do grafo e itera-los 
por essa ordem. 
  
  \begin{figure}[H]
    \center
    \includegraphics{graph_step0.png}
    \caption{Grafo de exemplo em que cada vértice foi-lhe atribuída uma \textit{label}(cor) inicial que é única.}
    \label{graph0llp}
  \end{figure}
  
  Neste contexto as \textit{labels} serão iteradas de forma a que seja dada uma maior importância à que o vértice tem e de seguida à que pertence ao vértice com menor ordem lexicográfica.

  Para $i=1$ admite-se que $\pi_1=$[N,H,M,B,J,L,G,D,K,E,I,F,C,A], $\gamma=1$(para facilitar) e que $v_i$=1 para todas as \textit{label}. Segundo o algoritmo \ref{apmalg} segue-se a iteração sobre $\pi_1$ e para cada vértice vê-se qual a \textit{label} que maximiza a Equação \ref{apmeq}. 
  %Nesta primeira iteração para qualquer vértice o resultado da equação \ref{apmeq} referente à sua \textit{label} não é o valor que maximiza porque $k_i=0$ e o mesmo acontece para as \textit{labels} que não se encontram na vizinhança, daí a omissão destes elementos. 
  \\[0.25cm]
  Exemplo para N:
  \begin{itemize}
   \item $label_n = k_n - \gamma ( v_n - k_n ) = 0 - 1 ( 1 - 0) = -1$
   \item $label_j = k_j - \gamma ( v_j - k_j ) = 1 - 1 ( 1 - 1) = 1$\\
   {\bf N fica com a \textit{label} de J.}
   \item $label_k = k_k - \gamma ( v_k - k_k ) = 1 - 1 ( 1 - 1) = 1$
   \item $label_l = k_l - \gamma ( v_l - k_l ) = 1 - 1 ( 1 - 1) = 1$ 
   \item $label_m = k_m - \gamma ( v_m - k_m ) = 1 - 1 ( 1 - 1) = 1$
  \end{itemize}
  Este cálculo é feito para todos os vértices pela ordem de $\pi_1$.  \\[0.25cm]
  \begin{figure}[H]
    \center
    \includegraphics{graph_stepAtE.png}
    \caption{Grafo de exemplo a iterar $\pi_1$ em E}
    \label{graphEllp}
  \end{figure}
  
  Exemplo para E:
  \begin{itemize}
   \item $label_e = k_e - \gamma ( v_e - k_e ) = 0 - 1 ( 1 - 0) = -1$
   \item $label_a = k_a - \gamma ( v_a - k_a ) = 1 - 1 ( 3 - 1) = -1$
   \item $label_f = k_f - \gamma ( v_f - k_f ) = 1 - 1 ( 3 - 1) = -1$ 
   \item $label_j = k_j - \gamma ( v_j - k_j ) = 1 - 1 ( 5 - 1) = -3$\\
   {\bf E mantém a sua \textit{label}.}
  \end{itemize}
  
  No final deste percorrer $\pi_1$ o grafo irá ter 4 comunidades com está apresentado na Figura \ref{graphfinalllp}.
  
  \begin{figure}[H]
    \center
    \includegraphics{graph_stepFinal.png}
    \caption{Grafo depois de iterar $\pi_1$ de acordo com o Algoritmo \ref{apmalg}.}
    \label{graphfinalllp}
  \end{figure}
  
  O algoritmo do \textit{Layered Label Propagation} após fazer o algoritmo de Absolute Pott Model reordena os vértices de acordo com a sua comunidade (mantendo a ordem dos vértices com a mesma comunidade) e volta a fazer este processo.

\newpage
\subsection{Algoritmo de \textit{Layered Label Propagation} Distribuído}

O algoritmo apresentado anteriormente pode ser usado em grafos de grandes dimensões em plataformas distribuídas. Contudo, existe algumas mudanças quanto à várias fazes do algoritmo. 

  O facto de se estar a usar uma plataforma distribuídas e a ordem que os vértices são iterados tem alguma aleatoriedade então a fase de obtenção da permutação do vértices é garantida. Após a obtenção da permutação como o algoritmo \ref{apmalg} indica, apenas é necessário iterar sobre as \textit{labels} que estão na vizinhança o que leva a que apenas haja comunicação entre vértices adjacentes. A comunicação entre vértices apenas é necessária para manter o estado de $v_i$ (apresentado na formula \ref{apmeq}) e só acontece quando um vértice muda a sua \textit{label}.
  \\[0,25cm]
  Para uma solução distribuída deste algoritmo cada vértice tem de ter:
  \begin{itemize}
   \item A sua \textit{label} actual e a sua \textit{label} antiga.
   \item Um histórico de pares \{$label_i$, $v_i$\} conhecidos até ao momento.
   \item Informação dos vértices adjacentes e respectivas \textit{labels}. 
  \\[0,25cm]
  \end{itemize}
  
  O algoritmo distribuído pode ser aplicado da seguinte forma:
  \begin{algorithm}[H]
    \caption{\textit{Layered Label Propagation} Distribuído}\label{llpdistributed}
    \begin{enumerate}
      \item Começar por atribuir uma \textit{label} única a cada vértice e atribuir a essa mesma \textit{label} um $v_i=1$. Enviar para os vértices adjacentes o pare \{$label_i$,$v_i$\}. De seguida guardar os vértices adjacentes e as suas respectivas \textit{labels}.
      \item Agregar todos os pares \{$label_i$, $v_i$\} que foram recebidos e actualizar as entradas de $v_i$ para cada $label_i$ correspondente. Caso necessário, subtrair a cada $v_i$ por cada mudança de \textit{label}.
      \item Calcular a formula \ref{apmeq} para as \textit{labels} que recebeu e para a sua \textit{label} actual independentemente se a recebeu ou não.Ver a \textit{label} que maximiza e caso a \textit{label} mude, enviar para os seus adjacentes o novo valor de $v_i$ correspondente à sua \textit{label} actual e a sua \textit{label} antiga. Voltar a repetir o processo a partir do ponto 2 até uma condição de paragem.
    \end{enumerate}
  \end{algorithm}

  A versão distribuída deste algoritmo não está acabada e será alterada. O algoritmo \ref{llpdistributed} ainda tem alguns problemas, em que as comunidades nas suas extremidades têm o valor de $v_i$ desactualizado.